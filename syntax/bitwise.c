//
// Created by dazuo on 2020/6/17.
//
#include <stdio.h>

// C语言位级运算和移位运算

void unsigned_int();
void original_code();
void bit_and_operator();
void bit_or_operator();
void bit_xor_operator();
void bit_negation_operator();
void bit_left_move();
void bit_right_move();
void bitwise_practice();

void learn_bitwise() {
    bitwise_practice();
}

// int 符号位取值范围
void unsigned_int() {
    int minInt = -2147483648;
    int maxInt = 2147483647;
    printf("min = %d, max = %d\n", minInt, maxInt);

    unsigned int maxUInt = 4294967295u;
    unsigned int minUInt = 0u;
    printf("min = %u, max = %u\n", minUInt, maxUInt);
}

void original_code() {
    /*
       一、机器数和真值
          1.机器数
            一个数在计算机中的二进制表示形式, 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0，负数为1。
            比如，十进制的数3，计算机字长为8位，转换成二进制就是00000011。那么，这里的00000011就是机器数。
          2.真值
            因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数10000011，其最高位1代表负，其真正数值是-3
            而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。
            例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1
       二、原码, 反码, 补码的基础概念和计算方法。
          对于一个数, 计算机要使用一定的编码方式进行存储。原码，反码，补码是机器存储一个具体数字的编码方式。
          1.原码
            用第一位表示符号，其余位表示值。
          2.反码
            正数的补码反码是其本身，负数的反码是符号位保持不变，其余位取反。例如：-1的原码是[1000 0001]，其反码是[1111 1110]
          3.补码
            正数的补码是其本身，负数的补码是在其反码的基础上+1；例如：-1的原码是[1000 0001]，反码是[1111 1110]，补码是[1111 1111]
       三、为何要使用原码, 反码和补码
          首先，因为人脑可以知道第一位是符号位，在计算的时候我们会根据符号位，选择对真值区域的加减。
          但是对于计算机，加减乘除已经是最基础的运算，要设计的尽量简单。计算机辨别"符号位"显然会让计算机的基础电路设计变得十分复杂!
          于是人们想出了将符号位也参与运算的方法。我们知道，根据运算法则减去一个正数等于加上一个负数，即: 1-1 = 1 + (-1) = 0，
          所以机器可以只有加法而没有减法，这样计算机运算的设计就更简单了。

          计算机中数据的`运算`和`存储`都是采用补码进行，数据展示，采用原码。

          最常见的有符号数的计算机表示方式就是补码形式。在这个定义中，将字的最高有效位解释为负权。
          C语言标准并没有要求要用补码形式来表示有符号整数，但是几乎所有的机器都是这么做的。
          C语言支持所有整型数据类型的有符号和无符号运算。尽管C语言并没有指定有符号数要采用某种表示，但是几乎所有的机器都使用补码。
          C语言允许无符号数与有符号数之间的转换。虽然C标准没有精确规定应如何进行这种转换，但大多数系统遵循的原则是底层的位表示保持不变。
     */

    /*
        原码： 0111 1111   // 127
        反码： 0111 1111
        补码： 0111 1111

        原码： 0000 0011   // 3
        反码： 0000 0011
        补码： 0000 0011

        0111 1111   // 127的补码
        0000 0011   // 3的补码
        1000 0010   // 127和3的补码运算结果

        要想展示这个数据，需要求其原码：
        1000 0010
        1111 1101   // 先求补码的反码
        1111 1110   // 再+1得到原码（补码的补码等于原码）
     */
    unsigned char a = 127u;
    printf("%u\n", (unsigned char)(a + 3u));
    printf("%d\n", (char)(a + 3u));         // 有符号输出，最高位作为符号位

    /*
        1000 1001   // -9的原码
        1111 0110   // -9的反码
        1111 0111   // -9的补码
    */
    // 有符号数 和 无符号数之间的转换，强制类型转换的结果是保持位值不变，只是改变了解释这些位的方式。
    char c = -9;
    printf("c = %d\n", (char)c);            // output: -9
    printf("c = %u\n", (unsigned char)c);   // output: 247  -> 1111 0111 （%u无符号输出，最高位作为值的一部分，正数补码的原码等于自身）
}

// 位与运算符
void bit_and_operator() {
    /*
          位与运算符为 &，其运算规则是：参与运算的数字，低位对齐，高位不足的补零，如果对应的二进制位同时为 1，那么计算结果才为 1，
          否则为 0。因此，任何数与 0 进行按位与运算，其结果都为 0。
            0000 0000 0000 0000 0000 0000 0000 1011    -> 11
          &
            0000 0000 0000 0000 0000 0000 0000 1001    -> 9
            ___________
            0000 0000 0000 0000 0000 0000 0000 1001    -> 9
     */
    unsigned int l = 11u;
    unsigned int r = 9u;
    printf("%u\n", l & r);

    /*
           1000 0000 0000 0000 0000 0000 0000 1011    -> -11
           1111 1111 1111 1111 1111 1111 1111 0101    -> -11 的补码
         &
           0000 0000 0000 0000 0000 0000 0000 1001    -> 9
           ___________
           0000 0000 0000 0000 0000 0000 0000 0001    -> 位与运算结果（补码），求其原码
    */
    l = (unsigned int)-11;
    r = 9u;
    printf("%u\n", l & r);
}

void bit_or_operator() {
    /*
        位或运算符为 |，其运算规则是：参与运算的数字，低位对齐，高位不足的补零。如果对应的二进制位只要有一个为 1，那么结果就为 1；
        如果对应的二进制位都为 0，结果才为 0。
            0000 0000 0000 0000 0000 0000 0000 1011    -> 11
          |
            0000 0000 0000 0000 0000 0000 0000 1001    -> 9
            _______________________________________________________________
            0000 0000 0000 0000 0000 0000 0000 1011    -> 11
     */
    unsigned int l = 11u;
    unsigned int r = 9u;
    printf("%u\n", l | r);

    /*
            1000 0000 0000 0000 0000 0000 0000 1011    -> -11
            1111 1111 1111 1111 1111 1111 1111 0101    -> -11 的补码
          |
            0000 0000 0000 0000 0000 0000 0000 1001    -> 9
            _______________________________________________________________
            1111 1111 1111 1111 1111 1111 1111 1101    -> 位或运算结果（补码）
            1000 0000 0000 0000 0000 0000 0000 0011    -> 求其原码
     */
    l = (unsigned int)-11;
    r = 9u;
    printf("%u\n", l | r);
}

void bit_xor_operator() {
    /*
        位异或运算符为 ^，其运算规则是：参与运算的数字，低位对齐，高位不足的补零，如果对应的二进制位相同（同时为 0 或同时为 1）时，
        结果为 0；如果对应的二进制位不相同，结果则为 1。
            0000 0000 0000 0000 0000 0000 0000 1011    -> 11
          ^
            0000 0000 0000 0000 0000 0000 0000 1001    -> 9
            _______________________________________________________________
            0000 0000 0000 0000 0000 0000 0000 0010    -> 2
     */
    unsigned int l = 11u;
    unsigned int r = 9u;
    printf("%u\n", l ^ r);

    /*
            0000 0000 0000 0000 0000 0000 0000 1011    -> -11
            1111 1111 1111 1111 1111 1111 1111 0101    -> -11 的补码
          ^
            0000 0000 0000 0000 0000 0000 0000 1001    -> 9
            _______________________________________________________________
            1111 1111 1111 1111 1111 1111 1111 1100    -> 位异或运算结果（补码）
            1000 0000 0000 0000 0000 0000 0000 0100    -> 求其原码
     */
    l = (unsigned int)-11;
    r = 9u;
    printf("%u\n", l ^ r);
}

void bit_negation_operator() {
    /*
          位取反运算符为 ~，将内存中的补码按位取反（包括符号位）其运算规则是：只对一个操作数进行运算，将操作数二进制中的 1 改为 0，0 改为 1。
            0000 0000 0000 0000 0000 0000 0000 1001    -> 9 (补码等于其本身）
            1111 1111 1111 1111 1111 1111 1111 0110    -> 将补码 按位取反
            按位取反后的补码，展示实际值需要先转换为原码
            1111 1111 1111 1111 1111 1111 1111 0101    -> -1 得到 反码
            1000 0000 0000 0000 0000 0000 0000 1010    -> 原码 = 反码符号位不变，其余取反
            原码计算值：-10
     */
    unsigned int l = 9u;
    printf("%u\n", ~l);


    /*
            1000 0000 0000 0000 0000 0000 0000 1001     -> -9
            1111 1111 1111 1111 1111 1111 1111 0111     -> -9 的补码
            0000 0000 0000 0000 0000 0000 0000 1000     -> 将补码 按位取反
            按位取反后的补码，展示实际值需要先转换为原码
            0000 0000 0000 0000 0000 0000 0000 1000     -> 原码
            原码计算值：8
     */
    l = (unsigned int)-9;
    printf("%u\n", ~l);
}

void bit_left_move() {
    /*
        左移位运算符为 <<，其运算规则是：按二进制形式把所有的数字向左移动对应的位数，高位移出（舍弃），低位的空位补零。
             移位前    0000 0000 0000 0000 0000 0000 0000 1001
             移位后  0 0000 0000 0000 0000 0000 0000 0001 0010
                    |                                       |
                    |                                       |
                   舍弃         左移1位计算过程                补0
     */
    unsigned int l = 9u;
    unsigned int r = 1u;
    printf("%u\n", l << r);

    /*
            移位前     1000 0000 0000 0000 0000 0000 0000 1001
            求补码     1111 1111 1111 1111 1111 1111 1111 0111
            码移位   1 1111 1111 1111 1111 1111 1111 1110 1110
                    |                                       |
                    |                                       |
                   舍弃          左移1位计算过程               补0
             求反码    1111 1111 1111 1111 1111 1111 1110 1101
             求原码    1000 0000 0000 0000 0000 0000 0001 0010
     */
    l = (unsigned int)-9;
    r = 1u;
    printf("%u\n", l << r);
}

// 机器支持两种形式的右移：
// - 逻辑右移：在左端补0
// - 算术右移：在左端补最高有效位的值

// C语言的标准并没有明确定义对于有符号位应该使用哪种类型的右移。不幸地，这意味着任何假设一种或者另一种右移形式的代码都可能遇到可移植性问题。
// 然而，实际上，几乎所有的编辑器/机器组合都对符号数使用了算术右移。另一方面，对于无符号数，右移必须是逻辑的。
// 与C相比，Java对于如何进行右移有明确的定义。表达式 x >> k会将x算术右移k个位置，而x >>> 会对x做逻辑右移。
void bit_right_move() {
    /*
        右位移运算符为 >>，其运算规则是：按二进制形式把所有的数字向右移动对应的位数，低位移出（舍弃），如果最高位是0就补0，如果最高位是1就补1。
            移位前     0000 0000 0000 0000 0000 0000 0000 1001
            移位后     0000 0000 0000 0000 0000 0000 0000 0100 1
                      |                                       |
                      |                                       |
                     补0         右移动1位计算过程              舍弃
    */
    unsigned int l = 9u;
    unsigned int r = 1u;
    printf("%u\n", l >> r);

    /*
        移位前     1000 0000 0000 0000 0000 0000 0000 1001     // -9
        取反码     1111 1111 1111 1111 1111 1111 1111 0110
        取补码     1111 1111 1111 1111 1111 1111 1111 0111
        移位后     0111 1111 1111 1111 1111 1111 1111 1011 1   // 逻辑右移
                  |                                       |
                  |                                       |
                 补0           右移动1位计算过程            舍弃
        取反码     0111 1111 1111 1111 1111 1111 1111 1011


        移位后     1111 1111 1111 1111 1111 1111 1111 1011 1   // 算术右移
                  |                                       |
                  |                                       |
                 补1           右移动1位计算过程            舍弃
        取反码     1000 0000 0000 0000 0000 0000 0000 0100
        取补码     1000 0000 0000 0000 0000 0000 0000 0101
     */
    l = (unsigned int)-9;
    r = 1u;

    printf("u = %u\n", l >> r);    // ouput: 2147483643   逻辑右移
    printf("d = %d\n", -9 >> r);   // output: -5          算术右移
}

// 时钟周期：时钟周期也称为振荡周期，定义为时钟频率的倒数。时钟周期是计算机中最基本的、最小的时间单位。
// 在一个时钟周期内，CPU仅完成一个最基本的动作。时钟周期是一个时间的量。时钟周期表示了SDRAM所能运行
// 的最高频率。更小的时钟周期就意味着更高的工作频率。

// 大多数机器上，整数乘法指令相当慢，需要10个或者更多的时钟周期，然而其他整数（例如：加法、减法、位级
// 运算和移位）只需要一个时钟周期。因此编译器使用率一项重要的优化，试着用移位和加法运算的组合来代替乘
// 以常数因子的乘法。
void bitwise_practice() {
    unsigned int l = 8u;
    unsigned int r = 1u;
    printf("%u\n", l << r);

    // 除以2的幂也可以用移位运算来实现，只不过我们用的是右移，而不是左移。
    printf("%u\n", l >> r);
}
